<?php
// $Id: services.module,v 1.8.2.88.2.6 2009/09/05 13:57:58 marcingy Exp $

/**
 * @author Services Dev Team
 * @file
 *  Provides a generic but powerful API for web services.
 */

/**
 * Implementation of hook_help().
 */
function services_help($path, $arg) {
  $output = NULL;

  switch ($path) {
    case 'admin/help#services':
      $output = '<p>'. t('Visit the <a href="@handbook_url">Services Handbook</a> for help and information.', array('@handbook_url' => 'http://drupal.org/node/109782')) .'</p>';
      break;
    case 'admin/build/services':
      $output = '<p>'. t('Services are collections of methods available to remote applications. They are defined in modules, and may be accessed in a number of ways through server modules. Visit the <a href="@handbook_url">Services Handbook</a> for help and information.', array('@handbook_url' => 'http://drupal.org/node/109782')) .'</p>';
      $output .= '<p>'. t('All enabled services and methods are shown. Click on any method to view information or test.') .'</p>';
      break;
  }

  return $output;
}

/**
 * Implementation of hook_perm().
 */
function services_perm() {
  return array('administer services');
}

/**
 * Implementation of hook_menu().
 */
function services_menu() {
  $items['admin/build/services'] = array(
    'title'             => 'Services',
    'description'       => 'Allows external applications to communicate with Drupal.',
    'access arguments'  => array('administer services'),
    'page callback'     => 'services_admin_endpoint_index',
    'file'              => 'includes/admin_endpoint.inc',
  );
  $items['admin/build/services/endpoints'] = array(
    'title'             => 'endpoints',
    'description'       => 'Administer the different services endpoints.',
    'type'              => MENU_DEFAULT_LOCAL_TASK,
    'weight'            => -10,
  );
  $items['admin/build/services/endpoint-add'] = array(
    'title'             => 'Add endpoint',
    'description'       => 'Add a services endpoint.',
    'page callback'     => 'drupal_get_form',
    'page arguments'    => array('services_admin_endpoint_add'),
    'access arguments'  => array('administer services'),
    'file'              => 'includes/admin_endpoint.inc',
    'type'              => MENU_LOCAL_TASK,
  );
  $items['admin/build/services/endpoints/%'] = array(
    'title callback'    => '_services_edit_endpoint_title',
    'title arguments'   => array('Edit !title', 4),
    'description'       => 'Edit a endpoint.',
    'page callback'     => 'drupal_get_form',
    'page arguments'    => array('services_admin_endpoint_edit', 4),
    'access arguments'  => array('administer services'),
    'file'              => 'includes/admin_endpoint.inc',
    'type'              => MENU_CALLBACK,
    'weight'            => -10,
  );
  $items['admin/build/services/endpoints/%/edit'] = array(
    'title'             => 'Edit',
    'description'       => 'Edit the endpoint.',
    'type'              => MENU_DEFAULT_LOCAL_TASK,
    'weight'            => -10,
  );
  $items['admin/build/services/endpoints/%/resources'] = array(
    'title'             => 'Resources',
    'description'       => 'Edit the resource settings for the endpoint.',
    'page callback'     => 'drupal_get_form',
    'page arguments'    => array('services_admin_endpoint_resources', 4),
    'access arguments'  => array('administer services'),
    'file'              => 'includes/admin_endpoint.inc',
    'type'              => MENU_LOCAL_TASK,
  );
  $items['admin/services/ahah/security-options'] = array(
    'file'              => 'includes/admin_endpoint.inc',
    'page callback'     => '_services_ahah_security_options',
    'access arguments'  => array('administer services'),
    'type'              => MENU_CALLBACK,
  );
  $items['crossdomain.xml'] = array(
    'access callback'   => 'services_access_menu',
    'page callback'     => 'services_crossdomain_xml',
    'type'              => MENU_CALLBACK,
  );

  // Add menu items for the different endpoints
  $endpoints = services_get_endpoints();
  foreach ($endpoints as $name => $endpoint) {
    $items[$endpoint['path']] = array(
      'title'             => 'Services endpoint',
      'access callback'   => 'services_access_menu',
      'page callback'     => 'services_server',
      'page arguments'    => array($endpoint['server'], $name, $endpoint['path']),
      'type'              => MENU_CALLBACK,
    );
  }

  return $items;
}

/**
 * Menu system title callback for the edit endpoint menu item.
 */
function _services_edit_endpoint_title($title, $endpoint) {
  $endpoint = services_get_endpoint($endpoint);
  return t($title, array(
    '!title' => $endpoint['title'],
  ));
}

/**
 * Implementation of hook_theme().
 */
function services_theme() {
  return array(
    'services_endpoint_index' => array(
      'template' => 'services_endpoint_index',
      'arguments' => array('endpoints' => NULL),
    ),
  );
}

/**
 * Implementation of hook_bypass_secure_site().
 */
function services_bypass_secure_site($path, $menu_item=NULL) {
  $bypass = FALSE;
  if ($menu_item && $menu_item['page_callback'] == 'services_server') {
    $endpoint = services_get_endpoint($menu_item['page_arguments'][1]);
    // Only bypass securesite if a authentication module is enabled.
    $bypass = $endpoint && !empty($endpoint['authentication']);
  }
  return $bypass;
}

/**
 * Returns information about the installed server modules on the system.
 *
 * @return array
 *  An associative array keyed after module name containing information about
 *  the installed server implementations.
 */
function services_get_servers() {
  static $servers;

  if (!$servers) {
    $servers = array();
    foreach (module_implements('server_info') as $module) {
      $servers[$module] = call_user_func($module . '_server_info');
    }
  }

  return $servers;
}

/**
 * Callback for server endpoint
 */
function services_server($server, $endpoint, $endpoint_path, $path) {
  if (function_exists($server . '_server')) {
    // call the server
    services_set_server_info_from_array(array(
      'module' => $server,
      'endpoint' => $endpoint,
      'endpoint_path' => $endpoint_path,
      'drupal_path' => getcwd(),
    ));

    print call_user_func($server . '_server', $endpoint, $endpoint_path);

    // Do not let this output
    module_invoke_all('exit');
    exit;
  }
  // return 404 if the server doesn't exist
  drupal_not_found();
}

/**
 * Callback for crossdomain.xml
 */
function services_crossdomain_xml() {
  $output = '<!DOCTYPE cross-domain-policy SYSTEM "http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd">'."\n";
  $output .= '<cross-domain-policy>' . "\n";

  $domains = module_invoke_all('services_crossdomain_domain_policy');
  drupal_alter('services_crossdomain_domain_policy', $domains);

  foreach ($domains as $domain => $info) {
    $output .= '  <allow-access-from domain="' . check_plain($domain) . '" />' . "\n";
    if ($info['subdomain_wildcard']) {
      $output .= '  <allow-access-from domain="*.' . check_plain($domain) . '" />' . "\n";
    }
  }

  $output .= '</cross-domain-policy>';

  services_xml_output($output);
}

/**
 * Implementation of hook_services_crossdomain_domain_policy().
 */
function services_services_crossdomain_domain_policy() {
  // Allow our own domain and it's subdomains
  return array(
    $_SERVER['HTTP_HOST'] => array(
      'subdomain_wildcard' => TRUE,
    ),
  );
}

/**
 * Helper function for services_crossdomain_xml().
 * Outputs the necessary http headers and xml processing instruction then exits.
 *
 * @param string $xml
 *  The xml document to print.
 * @return void
 *  This function never returns, it always exits.
 */
function services_xml_output($xml) {
  $xml = '<?xml version="1.0" encoding="UTF-8"?>' . "\n" . $xml;
  header('Connection: close');
  header('Content-Length: ' . strlen($xml));
  header('Content-Type: text/xml');
  header('Date: ' . date('r'));
  echo $xml;
  exit;
}

/**
 * Sets a server info value
 *
 * @param string $key
 *  The key of the server info value.
 * @param mixed $value
 *  The value.
 * @return void
 */
function services_set_server_info($key, $value) {
  $info = services_server_info_object();
  $info->$key = $value;
}

/**
 * Sets multiple server info values from a associative array.
 *
 * @param array $values
 *  An associative array containing server info values.
 * @return void
 */
function services_set_server_info_from_array($values) {
  $info = services_server_info_object();
  foreach ($values as $key => $value) {
    $info->$key = $value;
  }
}

/**
 * Gets a server info value.
 *
 * @param string $key
 *  The key for the server info value.
 * @param mixed $default
 *  The default value to return if the value isn't defined.
 * @return mixed
 *  The server info value.
 */
function services_get_server_info($key, $default = NULL) {
  $info = services_server_info_object();
  $value = $default;
  if (isset($info->$key)) {
    $value = $info->$key;
  }
  return $value;
}

/**
 * Gets the server info object.
 *
 * @param bool $reset
 *  Pass TRUE if the server info object should be reset.
 * @return object
 *  Returns the server info object.
 */
function services_server_info_object($reset = FALSE) {
  static $info;
  if (!$info) {
    $info = new stdClass();
  }
  return $info;
}

/**
 * Prepare an error message for returning to the server.
 */
function services_error($message, $code = 0, $exception = NULL) {
  $server_module = services_get_server_info('module');

  // Look for custom error handling function.
  // Should be defined in all server modules.
  if ($server_module && function_exists($server_module . '_server_error')) {
    $message = call_user_func($server_module . '_server_error', $message, $code, $exception);
  }

  return $message;
}

/**
 * Gets information about a authentication module.
 * If a property name is passed the value of the property will be returned,
 * otherwise the whole information array will be returned.
 *
 * @param string $property
 *  Optional. The name of a single property to get. Defaults to null.
 * @param string $module
 *  Optional. The module to get info for. Defaults to the current authentication module.
 * @return mixed
 *  The information array or property value, or FALSE if the information or property wasn't found
 */
function services_auth_info($property = NULL, $module = NULL) {
  static $info = array();
  // Default the module param to the current auth module
  $module = $module ? $module : variable_get('services_auth_module', '');

  if (!isset($info[$module])) {
    if (!empty($module) && module_exists($module) && is_callable($module . '_authentication_info')) {
      $info[$module] = call_user_func($module . '_authentication_info');
    }
    else {
      $info[$module] = FALSE;
    }
  }

  // If a property was requested it should be returned
  if ($property && $info[$module]) {
    return isset($info[$module][$property]) ? $info[$module][$property] : FALSE;
  }

  // Return the info array
  return $info[$module];
}

function services_auth_invoke($method, &$arg1 = NULL, &$arg2 = NULL, &$arg3 = NULL) {
  $module = variable_get('services_auth_module', '');
  // Get information about the current auth module
  $func = services_auth_info($method, $module);
  if ($func) {
    if ($file = services_auth_info('file')) {
      require_once(drupal_get_path('module', $module) . '/' . $file);
    }

    if (is_callable($func)) {
      $args = func_get_args();
      // Replace method name and arg1 with reference to $arg1 and $arg2.
      array_splice($args, 0, 3, array(&$arg1, &$arg2, &$arg3));
      return call_user_func_array($func, $args);
    }
  }
  else{
    return TRUE;
  }
}

function services_auth_invoke_custom($module, $method, &$arg1 = NULL, &$arg2 = NULL, &$arg3 = NULL) {
  // Get information about the auth module
  $func = services_auth_info($method, $module);
  if ($func) {
    if ($file = services_auth_info('#file', $module)) {
      require_once(drupal_get_path('module', $module) . '/' . $file);
    }

    if (is_callable($func)) {
      $args = func_get_args();
      // Replace module and method name and arg1 with reference to $arg1 and $arg2.
      array_splice($args, 0, 4, array(&$arg1, &$arg2, &$arg3));
      return call_user_func_array($func, $args);
    }
  }
  else{
    return TRUE;
  }
}

/**
 * Performs access checks and executes a services controller.
 * This method is called by server implementations.
 *
 * @param array $controller
 *  An array containing information about the controller
 * @param array $args
 *  The arguments that should be passed to the controller.
 * @param array $options
 *  Options for the execution. Use 'skip_authentication'=>TRUE to skip the
 *  services-specific authentication checks. Access checks will always be
 *  made.
 */
function services_controller_execute($controller, $args = array(), $options=array()) {
  // Check for missing arguments.
  $hash_parameters = array();
  foreach ($controller['args'] as $key => $arg) {
    if (!$arg['optional']) {
      if (!isset($args[$key]) && !is_array($args[$key]) && !is_bool($args[$key])) {
        return services_error(t('Missing required argument !name.', array(
          '!name' => $key,
        )), 406);
      }
    }
  }

  // Check authentication
  if (!isset($options['skip_authentication']) || !$options['skip_authentication']) {
    $endpoint_name = services_get_server_info('endpoint');
    $endpoint = services_get_endpoint($endpoint_name);

    if ($auth_error = services_auth_invoke_custom($endpoint['authentication'], 'authenticate_call', $controller, $args)) {
      return services_error($auth_error, 401);
    }
  }

  // Load the proper file
  if ($file = $controller['file']) {
    module_load_include($file['file'], $file['module']);
  }

  // Construct access arguments array
  if (isset($controller['access arguments'])) {
    $access_arguments = $controller['access arguments'];
    if (isset($controller['access arguments append']) && $controller['access arguments append']) {
      $access_arguments[] = $args;
    }
  }
  else {
    // Just use the arguments array if no access arguments have been specified
    $access_arguments = $args;
  }

  // Call default or custom access callback
  if (call_user_func_array($controller['access callback'], $access_arguments) != TRUE) {
    global $user;
    return services_error(t('Access denied for user !uid "@user"', array(
      '!uid' => $user->uid,
      '@user' => $user->name,
    )), 401);
  }

  // Change working directory to drupal root to call drupal function,
  // then change it back to server module root to handle return.
  $server_root = getcwd();
  $drupal_path = services_get_server_info('drupal_path');
  if ($drupal_path) {
    chdir($drupal_path);
  }

  // Execute the controller callback
  $result = call_user_func_array($controller['callback'], $args);

  if ($server_info) {
    chdir($server_root);
  }

  return $result;
}

/**
 * Formats a resource uri using the formatter registered through
 * services_set_server_info().
 *
 * @param array $path
 *  An array of strings containing the component parts of the path to the resource.
 * @return string
 *  Returns the formatted resource uri, or NULL if no formatter has been registered.
 */
function services_resource_uri($path) {
  $formatter = services_get_server_info('resource_uri_formatter');
  if ($formatter) {
    return call_user_func($formatter, $path);
  }
  return NULL;
}

/**
 * Gets a services endpoint
 *
 * @param string $name
 * @return array
 */
function services_get_endpoint($name) {
  $endpoints = services_get_endpoints();
  $endpoint = NULL;
  if (isset($endpoints[$name])) {
    $endpoint = $endpoints[$name];
  }
  return $endpoint;
}

/**
 * Saves a services endpoint.
 *
 * @param array $definition
 */
function services_write_endpoint($definition) {
  $encode = array(
    'authentication_settings', 'resources',
  );

  // Encode complex attributes as JSON
  foreach ($encode as $key) {
    if (isset($definition[$key])) {
      $definition[$key] = json_encode($definition[$key]);
    }
  }

  $update = db_result(db_query("SELECT COUNT(endpoint) FROM {services_endpoint} WHERE endpoint='%s'", array(
    ':endpoint' => $definition['endpoint'],
  ))) ? array('endpoint') : NULL;
  drupal_write_record('services_endpoint', $definition, $update);
}

/**
 * Gets all defined services endpoints.
 *
 * @param $include_disabled bool
 *  Pass TRUE if you want to include endpoints that are disabled.
 *  Defaults to FALSE.
 * @return array
 */
function services_get_endpoints($include_disabled=FALSE) {
  // Get all endpoints that are defined in code
  $endpoints = module_invoke_all('services_endpoints', $include_disabled);
  // Assign the endpoint name to the endpoint attribute to make
  // endpoint from code consistent with those loaded from db.
  foreach ($endpoints as $name => $def) {
    $endpoints[$name]['endpoint'] = $name;
  }

  // Allow modules to load endpoints from database sources
  $loaded = module_invoke_all('services_endpoints_load', $include_disabled);
  foreach ($loaded as $name => $def) {
    $endpoints[$name] = $def;
  }

  // Allow modules to alter the endpoints
  drupal_alter('services_endpoints', $endpoints);

  // Enforce the $include_disabled setting
  if (!$include_disabled) {
    foreach ($endpoints as $name => $def) {
      // When the enabled attribute isn't set it's interpreted as enabled
      if (isset($def['enabled']) && !$def['enabled']) {
        unset($endpoints[$name]);
      }
      else {
        $endpoints[$name]['enabled'] = TRUE;
      }
    }
  }

  return $endpoints;
}

/**
 * Implementation of hook_services_endpoints_load().
 */
function services_services_endpoints_load($include_disabled = FALSE) {
  $endpoints = array();

  // Load endpoint from the database
  if ($include_disabled) {
    $res = db_query('SELECT * FROM {services_endpoint}');
  }
  else {
    $res = db_query('SELECT * FROM {services_endpoint} WHERE enabled=1');
  }

  while ($row = db_fetch_array($res)) {
    $endpoints[$row['endpoint']] = _services_endpoint_from_result($row);
  }

  return $endpoints;
}

function _services_endpoint_from_result($row) {
  $decode = array(
    'authentication_settings', 'resources',
  );

  // Decode the json data
  foreach ($decode as $key) {
    if (!empty($row[$key])) {
      $row[$key] = json_decode($row[$key], TRUE);
    }
    else {
      unset($row[$key]);
    }
  }

  return $row;
}

/**
 * Gets all resource definitions.
 *
 * @param string $endpoint_name
 *   Optional. The endpoint endpoint that's being used. Defaults to NULL.
 * @return array
 *  An array containing all resources.
 */
function services_get_all_resources($endpoint_name=NULL) {
  $cache_key = empty($endpoint_name) ? 'services:resources' : 'services:' . $endpoint_name . ':resources';

  if (($cache = cache_get($cache_key)) && isset($cache->data)) {
    return $cache->data;
  }
  else {
    // Get all installed resources
    $resources = module_invoke_all('services_resources');

    $endpoint = NULL;
    if (!empty($endpoint_name)) {
      // Load the endpoint
      $endpoint = services_get_endpoint($endpoint_name);
      // Apply the endpoint on the services
      services_apply_endpoint($resources, $endpoint, TRUE);
    }

    drupal_alter('services_resources', $resources, $endpoint);

    $controllers = array();
    services_process_resources($resources, $controllers);

    // Make sure that we got a access callback for all resources
    foreach ($controllers as &$controller) {
      if (!isset($controller['access callback'])) {
        $controller['access callback'] = 'services_access_menu';
      }
    }

    drupal_alter('services_resources_post_processing', $resources, $endpoint);

    // Do some endpoint-dependent processing
    if ($endpoint) {
      // Let the authentication module alter our controllers
      if (!empty($endpoint['authentication'])) {
        services_auth_invoke_custom($endpoint['authentication'], 'alter_controllers', $controllers, $endpoint);
      }

      // Apply any aliases from endpoint
      if (!empty($endpoint))
      $aliased = array();
      foreach ($resources as $key => $def) {
        if (!empty($def['endpoint']['alias'])) {
          $aliased[$def['endpoint']['alias']] = $def;
        }
        else {
          $aliased[$key] = $def;
        }
      }
      $resources = $aliased;
    }

    cache_set($cache_key, $resources);
    return $resources;
  }
}

/**
 * Applies the endpoint to a set of resources. Resources and controllers that
 * aren't supported will be removed (if $strict is set to TRUE) and both
 * resources and controllers will get the 'endpoint' attribute set.
 *
 * @param array $resources
 *  An array of resources that the endpoint should be applied on.
 * @param array $endpoint
 *  A endpoint information array.
 * @param bool $strict
 *  Optional. 
 * @return void
 */
function services_apply_endpoint(&$resources, $endpoint, $strict=TRUE) {
  foreach ($resources as $name => &$resource) {
    $cres = $endpoint && isset($endpoint['resources'][$name]) ? $endpoint['resources'][$name] : array();
    $resource['endpoint'] = $cres;

    if ($strict && empty($cres)) {
      unset($resources[$name]);
    }
    else {
      $crud = array('create', 'retrieve', 'update', 'delete', 'index');
      foreach ($crud as $op) {
        $cop = isset($cres['operations'][$op]) ? $cres['operations'][$op] : array();
        $resource[$op]['endpoint'] = $cop;
        if ($strict && empty($cop)) {
          unset($resource['' . $op]);
        }
      }

      $classes = array('targeted actions', 'actions', 'relationships');
      foreach ($classes as $class) {
        if (!empty($resource[$class])) {
          foreach ($resource[$class] as $op => $def) {
            $cop = isset($cres[$class][$op]) ? $cres[$class][$op] : array();
            if (empty($cop)) {
              if ($strict) {
                unset($resource['' . $op]);
              }
            }
            else {
              $resource[$class][$op]['endpoint'] = $cop;
            }
          }
        }
      }
    }
  }
}

function services_process_resources(&$resources, &$controllers, $path=array()) {
  foreach ($resources as $name => &$resource) {
    _services_process_resource($name, $resource, $controllers);
  }
}

/**
 * Process resource runs through all the controllers of a resource and applies
 * some inheritance logic and adds the to the $controllers array.
 *
 * @param string $name
 *  The name of the resource
 * @param array &$resource
 *  The resource definition
 * @param array &$controllers
 *  An that will be fillew with all the controllers for the resource.
 * @return void
 */
function _services_process_resource($name, &$resource, &$controllers) {
  $resource['name'] = $name;

  $keys = array('retrieve','create','update','delete');
  foreach ($keys as $key) {
    if (isset($resource[$key])) {
      $controllers[$name . '/' . $key] = &$resource[$key];
    }
  }

  if (isset($resource['index'])) {
    $controllers[$name . '/index'] = &$resource['index'];
  }

  if (isset($resource['relationships'])) {
    foreach ($resource['relationships'] as $relname => $rel) {
      // Run some inheritance logic
      if (isset($resource['retrieve'])) {
        if (empty($rel['args']) || $rel['args'][0]['name'] !== $resource['retrieve']['args'][0]['name']) {
          array_unshift($rel['args'], $resource['retrieve']['args'][0]);
        }
        $resource['relationships'][$relname] = array_merge($resource['retrieve'], $rel);
      }
      $controllers[$name . '/relationship/' . $relname] = &$resource['relationships'][$relname];
    }
  }

  if (isset($resource['actions'])) {
    foreach ($resource['actions'] as $actname => $act) {
      // Run some inheritance logic
      if (isset($resource['update'])) {
        $up = $resource['update'];
        unset($up['args']);
        $resource['actions'][$actname] = array_merge($up, $act);
      }
      $controllers[$name . '/action/' . $actname] = &$resource['actions'][$actname];
    }
  }

  if (isset($resource['targeted actions'])) {
    foreach ($resource['targeted actions'] as $actname => $act) {
      // Run some inheritance logic
      if (isset($resource['update'])) {
        if (empty($act['args']) || $act['args'][0]['name'] !== $resource['update']['args'][0]['name']) {
          array_unshift($act['args'], $resource['update']['args'][0]);
        }
        $resource['targeted actions'][$actname] = array_merge($resource['update'], $act);
      }
      $controllers[$name . '/targeted_action/' . $actname] = &$resource['actions'][$actname];
    }
  }
}

function services_method_get($method_name, $endpoint='') {
  // TODO: This function must be rewritten to support the resource model
}

/**
 * Make any changes we might want to make to node.
 */
function services_node_load($node, $fields = array()) {
  if (!isset($node->nid)) {
    return NULL;
  }

  // Loop through and get only requested fields
  if (count($fields) > 0) {
    foreach ($fields as $field) {
      $val->{$field} = $node->{$field};
    }
  }
  else {
    $val = $node;
  }

  return $val;
}

/**
 * Backup current session data and import user session.
 */
function services_session_load($sessid) {
  global $user;

  // If user's session is already loaded, just return current user's data
  if ($user->sid == $sessid) {
    return $user;
  }

  // Make backup of current user and session data
  $backup = $user;
  $backup->session = session_encode();

  // Empty current session data
  $_SESSION = array();

  // Some client/servers, like XMLRPC, do not handle cookies, so imitate it to make sess_read() function try to look for user,
  // instead of just loading anonymous user :).
  if (!isset($_COOKIE[session_name()])) $_COOKIE[session_name()] = $sessid;

  // Load session data
  session_id($sessid);
  sess_read($sessid);

  // Check if it really loaded user and, for additional security, if user was logged from the same IP. If not, then revert automatically.
  if ($user->sid != $sessid) {
    services_session_unload($backup);
    return NULL;
  }

  // Prevent saving of this impersonation in case of unexpected failure.
  session_save_session(FALSE);

  return $backup;
}

/**
 * Revert to previously backuped session.
 */
function services_session_unload($backup) {
  global $user;

  // No point in reverting if it's the same user's data
  if ($user->sid == $backup->sid) {
    return;
  }

  // Some client/servers, like XMLRPC, do not handle cookies, so imitate it to make sess_read() function try to look for user,
  // instead of just loading anonymous user :).
  if (!isset($_COOKIE[session_name()])) $_COOKIE[session_name()] = $backup->sessid;

  // Save current session data
  sess_write($user->sid, session_encode());

  // Empty current session data
  $_SESSION = array();

  // Revert to previous user and session data
  $user = $backup;
  session_id($backup->sessid);
  session_decode($user->session);

  session_save_session(TRUE);
}

/**
 * Return true so as services menu callbacks work
 */
function services_access_menu() {
  return TRUE;
} 