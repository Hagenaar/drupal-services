<?php
// $Id: services.module,v 1.8.2.88.2.6 2009/09/05 13:57:58 marcingy Exp $

/**
 * @author Services Dev Team
 * @file
 *  Provides a generic but powerful API for web services.
 */

/**
 * Implementation of hook_help().
 */
function services_help($path, $arg) {
  $output = NULL;

  switch ($path) {
    case 'admin/help#services':
      $output = '<p>'. t('Visit the <a href="@handbook_url">Services Handbook</a> for help and information.', array('@handbook_url' => 'http://drupal.org/node/109782')) .'</p>';
      break;
    case 'admin/build/services':
      $output = '<p>'. t('Services are collections of methods available to remote applications. They are defined in modules, and may be accessed in a number of ways through server modules. Visit the <a href="@handbook_url">Services Handbook</a> for help and information.', array('@handbook_url' => 'http://drupal.org/node/109782')) .'</p>';
      $output .= '<p>'. t('All enabled services and methods are shown. Click on any method to view information or test.') .'</p>';
      break;
  }

  return $output;
}

/**
 * Implementation of hook_perm().
 */
function services_perm() {
  return array('administer services');
}

/**
 * Implementation of hook_menu().
 */
function services_menu() {
  $items['admin/build/services'] = array(
    'title'             => 'Services',
    'description'       => 'Allows external applications to communicate with Drupal.',
    'access arguments'  => array('administer services'),
    'page callback'     => 'services_admin_endpoint_index',
    'file'              => 'includes/admin_endpoint.inc',
  );
  $items['admin/build/services/endpoints'] = array(
    'title'             => 'endpoints',
    'description'       => 'Administer the different services endpoints.',
    'type'              => MENU_DEFAULT_LOCAL_TASK,
    'weight'            => -10,
  );
  $items['admin/build/services/endpoint-add'] = array(
    'title'             => 'Add endpoint',
    'description'       => 'Add a services endpoint.',
    'page callback'     => 'drupal_get_form',
    'page arguments'    => array('services_admin_endpoint_add'),
    'access arguments'  => array('administer services'),
    'file'              => 'includes/admin_endpoint.inc',
    'type'              => MENU_LOCAL_TASK,
  );
  $items['admin/build/services/endpoints/%'] = array(
    'title callback'    => '_services_edit_endpoint_title',
    'title arguments'   => array('Edit !title', 4),
    'description'       => 'Edit a endpoint.',
    'page callback'     => 'drupal_get_form',
    'page arguments'    => array('services_admin_endpoint_edit', 4),
    'access arguments'  => array('administer services'),
    'file'              => 'includes/admin_endpoint.inc',
    'type'              => MENU_CALLBACK,
    'weight'            => -10,
  );
  $items['admin/build/services/endpoints/%/edit'] = array(
    'title'             => 'Edit',
    'description'       => 'Edit the endpoint.',
    'type'              => MENU_DEFAULT_LOCAL_TASK,
    'weight'            => -10,
  );
  $items['admin/build/services/endpoints/%/resources'] = array(
    'title'             => 'Resources',
    'description'       => 'Edit the resource settings for the endpoint.',
    'page callback'     => 'drupal_get_form',
    'page arguments'    => array('services_admin_endpoint_resources', 4),
    'access arguments'  => array('administer services'),
    'file'              => 'includes/admin_endpoint.inc',
    'type'              => MENU_LOCAL_TASK,
  );
  $items['admin/services/ahah/security-options'] = array(
    'file'              => 'includes/admin_endpoint.inc',
    'page callback'     => '_services_ahah_security_options',
    'access arguments'  => array('administer services'),
    'type'              => MENU_CALLBACK,
  );
  $items['crossdomain.xml'] = array(
    'access callback'   => 'services_access_menu',
    'page callback'     => 'services_crossdomain_xml',
    'type'              => MENU_CALLBACK,
  );

  // Add menu items for the different endpoints
  $endpoints = services_get_endpoints();
  foreach ($endpoints as $name => $endpoint) {
    $items[$endpoint['path']] = array(
      'title'             => 'Services endpoint',
      'access callback'   => 'services_access_menu',
      'page callback'     => 'services_endpoint_callback',
      'page arguments'    => array($name),
      'type'              => MENU_CALLBACK,
    );
  }

  return $items;
}

/**
 * Menu system title callback for the edit endpoint menu item.
 */
function _services_edit_endpoint_title($title, $endpoint) {
  $endpoint = services_get_endpoint($endpoint);
  return t($title, array(
    '!title' => $endpoint['title'],
  ));
}

/**
 * Access callback that always returns TRUE.
 */
function services_access_menu() {
  return TRUE;
}

/**
 * Implementation of hook_theme().
 */
function services_theme() {
  return array(
    'services_endpoint_index' => array(
      'template' => 'services_endpoint_index',
      'arguments' => array('endpoints' => NULL),
    ),
  );
}

/**
 * Implementation of hook_bypass_secure_site().
 */
function services_bypass_secure_site($path, $menu_item=NULL) {
  $bypass = FALSE;
  if ($menu_item && $menu_item['page_callback'] == 'services_server') {
    $endpoint = services_get_endpoint($menu_item['page_arguments'][1]);
    // Only bypass securesite if a authentication module is enabled.
    $bypass = $endpoint && !empty($endpoint['authentication']);
  }
  return $bypass;
}

/**
 * Returns information about the installed server modules on the system.
 *
 * @return array
 *  An associative array keyed after module name containing information about
 *  the installed server implementations.
 */
function services_get_servers() {
  static $servers;

  if (!$servers) {
    $servers = array();
    foreach (module_implements('server_info') as $module) {
      $servers[$module] = call_user_func($module . '_server_info');
    }
  }

  return $servers;
}

/**
 * Menu system page callback for server endpoints.
 *
 * @param string $endpoint
 *  The endpoint name.
 * @return void
 */
function services_endpoint_callback($endpoint_name) {
  module_load_include('inc', 'services', 'includes/runtime');

  $endpoint = services_get_endpoint($endpoint_name);
  $server = $endpoint['server'];

  if (function_exists($server . '_server')) {
    // call the server
    services_set_server_info_from_array(array(
      'module' => $server,
      'endpoint' => $endpoint_name,
      'endpoint_path' => $endpoint['path'],
      'drupal_path' => getcwd(),
    ));

    print call_user_func($server . '_server');

    // Do not let this output
    module_invoke_all('exit');
    exit;
  }
  // return 404 if the server doesn't exist
  drupal_not_found();
}

/**
 * Callback for crossdomain.xml
 */
function services_crossdomain_xml() {
  $output = '<!DOCTYPE cross-domain-policy SYSTEM "http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd">'."\n";
  $output .= '<cross-domain-policy>' . "\n";

  $domains = module_invoke_all('services_crossdomain_domain_policy');
  drupal_alter('services_crossdomain_domain_policy', $domains);

  foreach ($domains as $domain => $info) {
    $output .= '  <allow-access-from domain="' . check_plain($domain) . '" />' . "\n";
    if ($info['subdomain_wildcard']) {
      $output .= '  <allow-access-from domain="*.' . check_plain($domain) . '" />' . "\n";
    }
  }

  $output .= '</cross-domain-policy>';

  services_xml_output($output);
}

/**
 * Implementation of hook_services_crossdomain_domain_policy().
 */
function services_services_crossdomain_domain_policy() {
  // Allow our own domain and it's subdomains
  return array(
    $_SERVER['HTTP_HOST'] => array(
      'subdomain_wildcard' => TRUE,
    ),
  );
}

/**
 * Helper function for services_crossdomain_xml().
 * Outputs the necessary http headers and xml processing instruction then exits.
 *
 * @param string $xml
 *  The xml document to print.
 * @return void
 *  This function never returns, it always exits.
 */
function services_xml_output($xml) {
  $xml = '<?xml version="1.0" encoding="UTF-8"?>' . "\n" . $xml;
  header('Connection: close');
  header('Content-Length: ' . strlen($xml));
  header('Content-Type: text/xml');
  header('Date: ' . date('r'));
  echo $xml;
  exit;
}

/**
 * Gets a services endpoint
 *
 * @param string $name
 * @return array
 */
function services_get_endpoint($name) {
  $endpoints = services_get_endpoints();
  $endpoint = NULL;
  if (isset($endpoints[$name])) {
    $endpoint = $endpoints[$name];
  }
  return $endpoint;
}

/**
 * Saves a services endpoint.
 *
 * @param array $definition
 */
function services_write_endpoint($definition) {
  $encode = array(
    'authentication_settings', 'resources',
  );

  // Encode complex attributes as JSON
  foreach ($encode as $key) {
    if (isset($definition[$key])) {
      $definition[$key] = json_encode($definition[$key]);
    }
  }

  $update = db_result(db_query("SELECT COUNT(endpoint) FROM {services_endpoint} WHERE endpoint='%s'", array(
    ':endpoint' => $definition['endpoint'],
  ))) ? array('endpoint') : NULL;
  drupal_write_record('services_endpoint', $definition, $update);

  // Clear the cache for the endpoint
  cache_clear_all('services:' . $definition['endpoint'] . ':', 'cache', TRUE);
}

/**
 * Gets all defined services endpoints.
 *
 * @param $include_disabled bool
 *  Pass TRUE if you want to include endpoints that are disabled.
 *  Defaults to FALSE.
 * @return array
 */
function services_get_endpoints($include_disabled=FALSE) {
  // Get all endpoints that are defined in code
  $endpoints = module_invoke_all('services_endpoints', $include_disabled);
  // Assign the endpoint name to the endpoint attribute to make
  // endpoint from code consistent with those loaded from db.
  foreach ($endpoints as $name => $def) {
    $endpoints[$name]['endpoint'] = $name;
  }

  // Allow modules to load endpoints from database sources
  $loaded = module_invoke_all('services_endpoints_load', $include_disabled);
  foreach ($loaded as $name => $def) {
    $endpoints[$name] = $def;
  }

  // Allow modules to alter the endpoints
  drupal_alter('services_endpoints', $endpoints);

  // Enforce the $include_disabled setting
  if (!$include_disabled) {
    foreach ($endpoints as $name => $def) {
      // When the enabled attribute isn't set it's interpreted as enabled
      if (isset($def['enabled']) && !$def['enabled']) {
        unset($endpoints[$name]);
      }
      else {
        $endpoints[$name]['enabled'] = TRUE;
      }
    }
  }

  return $endpoints;
}

/**
 * Implementation of hook_services_endpoints_load().
 */
function services_services_endpoints_load($include_disabled = FALSE) {
  $endpoints = array();

  // Load endpoint from the database
  if ($include_disabled) {
    $res = db_query('SELECT * FROM {services_endpoint}');
  }
  else {
    $res = db_query('SELECT * FROM {services_endpoint} WHERE enabled=1');
  }

  while ($row = db_fetch_array($res)) {
    $endpoints[$row['endpoint']] = _services_endpoint_from_result($row);
  }

  return $endpoints;
}

function _services_endpoint_from_result($row) {
  $decode = array(
    'authentication_settings', 'resources',
  );

  // Decode the json data
  foreach ($decode as $key) {
    if (!empty($row[$key])) {
      $row[$key] = json_decode($row[$key], TRUE);
    }
    else {
      unset($row[$key]);
    }
  }

  return $row;
}

/**
 * Gets all resource definitions.
 *
 * @param string $endpoint_name
 *   Optional. The endpoint endpoint that's being used.
 * @return array
 *  An array containing all resources.
 */
function services_get_resources($endpoint_name='') {
  $cache_key = 'services:' . $endpoint_name . ':resources';

  $resources = array();
  if (($cache = cache_get($cache_key)) && isset($cache->data)) {
    $resources = $cache->data;
  }
  else {
    module_load_include('inc', 'services', 'includes/resource_build');
    $resources = _services_build_resources($endpoint_name);
    cache_set($cache_key, $resources);
  }

  return $resources;
}

/**
 * Implementation of hook_services_resources().
 */
function services_services_resources() {
  module_load_include('inc', 'services', 'includes/resource_build');
  // Return resources representing legacy services
  return _services_legacy_services_as_resources();
}

/**
 * Returns all the controller names for a endpoint.
 *
 * @param string $endpoint
 *  The endpoint that should be used.
 * @param array $names
 *  An array of prefixes to use for 'actions', 'relationships' and 'targeted
 *  actions'. The default mapping is 'actions'=>'do', 'relationships'=>'get'
 *  and 'targeted actions'=>'set'.
 * @param bool $key_by_resource
 *  Optional. Set to TRUE to get controllers separated by resource.
 * @return array
 *  Either a non associative array containing all controller names. Or, if
 *  $key_by_resource was set to TRUE, a associative array where the resource
 *  name is the key and the value is a non-associative array containing the
 *  resource's controller names.
 */
function services_controllers_list($endpoint, $prefixes = array(), $key_by_resource=FALSE) {
  $controllers = array();
  $prefixes = array_merge(
    array(
      'actions' => 'do',
      'relationships' => 'get',
      'targeted actions' => 'set',
    ), $prefixes);
  $resources = services_get_resources($endpoint);

  foreach ($resources as $resource_name => $res) {
    // Get all basic operations
    foreach (array('create', 'retrieve', 'update', 'delete', 'index') as $op) {
      if (isset($res[$op])) {
        $controllers[] = $resource_name . '.' . $op;
      }
    }
    foreach ($prefixes as $op => $prefix) {
      if (isset($res[$op])) {
        foreach ($res['op'] as $name => $def) {
          // Append prefix if it isn't empty
          if (!empty($prefix)) {
            $name = $prefix . '_' . $name;
          }
          $controllers[] = $resource_name . '.' . $name;
        }
      }
    }
  }
  return $controllers;
}

/**
 * Returns the requested controller.
 *
 * @param string $name
 *  The name of the controller in the format: {resource}.{prefix}_{name} or
 *  {resource}.{operation}. Examples: "node.retrieve", "node.create",
 *  "node.get_comments" and "node.set_publish".
 * @param string $endpoint
 *  The endpoint that should be used.
 * @param array $names
 *  An array of prefixes to use for 'actions', 'relationships' and 'targeted
 *  actions'. The default mapping is 'actions'=>'do', 'relationships'=>'get'
 *  and 'targeted actions'=>'set'.
 */
function services_controller_get($name, $endpoint, $prefixes = array()) {
  list($resource_name, $method) = explode('.', $name);
  $controller = FALSE;

  $resources = services_get_resources($endpoint);

  if (isset($resources[$resource_name])) {
    $res = $resources[$resource_name];
    $qual = explode('_', $method, 2);

    if (count($qual) == 1) {
      switch ($qual[0]) {
        case 'create':
        case 'retrieve':
        case 'update':
        case 'delete':
        case 'index':
          if (isset($res[$qual[0]])) {
            $controller = $res[$qual[0]];
          }
          break;
      }
    }
    else if (count($qual) == 2) {
      // Set up names with default values
      $prefixes = array_merge(
        array(
          'actions' => 'do',
          'relationships' => 'get',
          'targeted actions' => 'set',
        ), $prefixes);

      // Find a matching controller
      foreach ($prefixes as $op => $prefix) {
        if ($qual[0] == $prefix) {
          if (isset($res[$op]) && isset($res[$op][$qual[1]])) {
            $controller = $res[$op][$qual[1]];
            break;
          }
        }
      }
    }
  }
  return $controller;
}
